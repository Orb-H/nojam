---
title: 사칙연산 / 수 자료형
order: 11
category: 노트
layout: note

diff: "<span class='diff_bronze'>Bronze V</span>"

written: "2021-01-16 23:59"
edited: 
---

사칙연산은 덧셈, 뺄셈, 곱셈, 나눗셈의 네 가지 연산을 지칭하는 단어이다. 보통 프로그래밍 언어는 사칙연산을 기본적으로 제공한다.

### 연산의 종류

#### 더하기

대부분의 프로그래밍 언어에서는 `+` 연산자를 이용하여 덧셈을 표현한다. 수학에서 `1 + 2 = 3`라고 쓰듯이 프로그래밍에서도 `1 + 2`는 `3`을 반환한다. 아래의 코드를 실행해서 그 결과를 확인할 수 있다.

```cpp
#include <iostream>
using namespace std;
int main() {
    cout << 1 + 2 << endl;
    cout << 2.1 + 4.7 << endl;
}
```

출력창을 보면 `3`과 `6.8`이라고 적혀있다. 이제 수를 바꿔서 조금 큰 자연수의 덧셈도 해볼 수 있겠고, 음수의 덧셈, 실수의 덧셈, 양수와 음수의 덧셈 등 여러 가지를 해볼 수 있다. 적당한 범위에서는 아주 잘 작동한다.

#### 빼기

뺄셈은 `-` 연산자를 사용하여 표현한다. 이 또한 일반적인 뺄셈과 동일하게 작동한다. 적당한 범위의 수에 대해서 뺄셈을 진행하면 우리가 이미 수학에서 배웠던 것과 똑같은 결과가 나올 것이다.

```cpp
#include <iostream>
using namespace std;
int main() {
    cout << 65 - 32 << endl;
    cout << 10.2 - 11 << endl;
}
```

위의 코드는 `33`과 `-0.8`을 출력한다. 양수의 결과값은 물론 음수의 결과값도 잘 나오는 것을 확인할 수 있다. 물론 적당한 범위의 정수 및 실수에 대해서이다.

#### 곱하기

곱하기는 `*` 연산자를 사용한다. 마찬가지로 우리가 아는 곱셈과 같은 결과를 반환한다. 사실 그렇지 않다면 굳이 쓸 필요가 없을 것이다.

```cpp
#include <iostream>
using namespace std;
int main() {
    cout << 6 * 4 << endl;
    cout << (-3.1) * 7 << endl;
}
```

위의 코드는 `24`와 `-21.7`을 출력한다. 다양한 값을 넣어서 결과값을 확인해볼 수 있는데, 정수는 여섯 자리 이상으로만 올려도 값이 이상해진다. 그 이유는 후술하도록 한다.

#### 나누기

나누기는 `/` 연산자를 사용한다. 나누기 연산은 조금 특이한게 피연산자의 타입에 따라 연산이 조금 달라진다. 정수일 때와 실수일 때 그 연산이 다른데, 아래의 코드를 실행해보면서 확인할 수 있다.

```cpp
#include <iostream>
using namespace std;
int main() {
    cout << 12 / 5 << endl;
    cout << 12.0 / 5.0 << endl;
}
```

위 코드의 결과값은 `2`와 `2.4`이다. 숫자를 바꾸어가면서 테스트를 해보면 정수끼리의 나눗셈은 몫 연산, 실수끼리의 나눗셈은 실제 나눗셈 연산임을 확인할 수 있다.

#### 나머지

나머지는 `%` 연산자를 사용한다. 두 수 A와 B의 나머지 연산은 $B=Aq+r(A, B, q\in\mathbb{Z},0\le r\lt A)$의 관계식으로 정의되는데, 이 때 r이 나머지가 된다. 관계식에서 조건으로 주어졌듯이, 나머지 연산은 두 수가 정수일 때만 정의한다. 따라서 실수일 때에는 작동하지 않는다. C/C++에서는 이에 대해 컴파일 에러를 띄운다.

다만 Java와 Python은 위 관계식을 확장시켜서 실수일 때도 돌아가게끔 해놓았다. 정확히는 관계식을 $B-Aq=r$로 고친 후, r이 원하는 범위로 들어올 때까지 B에서 A를 계속 뺀다. 그러다가 r이 적당한 값이 되면 뺄셈을 멈추고 남은 값을 출력한다.

```cpp
#include <iostream>
using namespace std;
int main() {
    cout << 7 % 3 << endl;
    cout << 7.0 % 3 << endl; // Compile Error
}
```

```java
public class Main {
    public static void main(String[] args) {
        System.out.println(7 % 3);
        System.out.println(7.0 % 3.0); // Works well
    }
}
```

### 결과값이 이상해요: 정수

위에서 덧셈이나 뺄셈을 진행할 때 조금 큰 값을 넣고 돌려보면 원하는 결과가 아닌 값을 얻을 수 있다. 예를 들면, 아래와 같은 코드이다.

```cpp
#include <iostream>
using namespace std;
int main() {
    cout << 2000000000 + 2000000000 << endl;
}
```

이 코드를 돌리면 `4000000000`이 나올 것을 예상하겠지만 실제로는 `-294967296`라는 값이 나온다. 이것은 정수형에 대해 알면 왜 그런지 이해를 할 수 있다.

#### 정수형의 범위와 오버플로우

정수형은 Python처럼 거의 무한한 값을 저장할 수 있는 형태가 아닌 이상 범위를 가진다. C/C++의 경우는 아래와 같다.(x64)

|타입|범위|크기|
|:-:|:-:|:-:|
|char|-128~127 / -2<sup>7</sup>~2<sup>7</sup>-1|1 byte|
|unsigned char|0~255 / 0~2<sup>8</sup>-1|1 byte|
|short|-32768~32767 / -2<sup>15</sup>~2<sup>15</sup>-1|2 bytes|
|unsigned short|0~65535 / 0~2<sup>16</sup>-1|2 bytes|
|int|-2147483648~2147483647 / -2<sup>31</sup>~2<sup>31</sup>-1|4 bytes|
|unsigned int|0~4294967295 / 0~2<sup>32</sup>-1|4 bytes|
|long|int 또는 long long과 같은 범위[^1]|4 or 8 bytes|
|unsigned long|unsigned int 또는 unsigned long long과 같은 범위[^1]|4 or 8 bytes|
|long long|-9223372036854775808~9223372036854775807 / -2<sup>63</sup>~2<sup>63</sup>-1|8 bytes
|unsigned long long|0~18846744073709551613 / 0~2<sup>64</sup>-1|8 bytes

위의 표에서 `int`를 예시로 들면, `int`는 32비트(4바이트) 중에서 가장 왼쪽에 있는 1비트를 부호를 나타내는 데에 사용한다.[^2] 이 비트값이 0이면 0을 포함한 양수, 1이면 음수를 나타내는 것이다. n번째 비트를 b<sub>n</sub>라고 하면 `int` 형의 비트 배열 {b<sub>i</sub>}은 $-2^{31}b_{31}+2^{30}b_{30}+...+2^{1}b_{1}$을 나타낸다. b<sub>i</sub>는 0 또는 1이기 때문에 `int`의 범위가 위와 같이 정해진다.

이제 두 `int` 변수의 덧셈을 생각해보자. CPU 위에서 돌아가는 `add` 명령(어셈블리)은 부호를 신경쓰지 않고 32비트 전체에 대해 가산 연산을 진행한다. 이제 2000000000을 비트로 나타내보면 `01110111 00110101 10010100 00000000`이 되고, 여기에 2000000000을 또 더하면 `11101110 01101011 00101000 00000000`이 될 것이다. 그런데 가장 왼쪽 비트를 보면 1이다. 따라서 이 수는 음수임을 알 수 있고, 2의 보수법을 이용하여 부호를 +로 바꿔보면 `00010001 10010100 11011000 00000000`, 294967296이다. 따라서 `int`의 범위 안에서는 `2000000000 + 2000000000`가 -294967296이 되는 것이다. 이런 식으로 부호가 아닌 데이터가 부호 비트에 영향을 주거나, 연산의 결과가 변수 자체의 크기보다 커서 잘려나가는 것을 오버플로우라고 한다.

#### 정수형 상수의 타입 표기

C/C++에서 그냥 숫자만 입력해서 정수형 변수에 값을 대입하는 경우가 있다. 이 때 이 숫자는 `int`형으로 컴파일러가 자동으로 인식한다. 그러면 `int`형 밖의 정수는 어떻게 해야할까? 이를 위해서 주어진 상수를 어떤 타입으로 접미사가 존재한다. 그 종류는 아래와 같다.

|접미사|타입|
|:-:|:-:|
|(없음)|int|
|U, u|unsigned int|
|L, l|long|
|UL, ul|unsigned long|
|LL, ll|long long|
|ULL, ull|unsigned long long|

예를 들어, 1000000000000000이라는 상수(int 범위를 한참 벗어난다!)를 unsigned long long의 형태로 저장하고 싶다면, 아래와 같이 하면 된다.

```cpp
unsigned long long n = 1000000000000000ULL;
```

#### 고정적인 정수형

`int`나 `long` 같은 타입들은 환경에 따라 그 크기가 변할 수 있다. 예를 들어, 성능은 썩 아니지만 충분히 작은 CPU가 필요한 시스템은 더 작은 크기를 할당하여 사용해야할 수도 있다. 하지만 이와 같은 환경에 상관없이 언제 어디서나 일정한 크기를 가져야 하는 값이 있을 수 있다. 이 때 사용할 수 있는 타입이 있다. 그 종류는 아래와 같다.(C/C++)

|타입|의미|범위|크기|
|:-:|:-:|:-:|:-:|
|int8_t|8비트 크기의 부호있는 정수|-2<sup>7</sup>~2<sup>7</sup>-1|1 byte|
|int16_t|16비트 크기의 부호있는 정수|-2<sup>15</sup>~2<sup>15</sup>-1|2 bytes|
|int32_t|32비트 크기의 부호있는 정수|-2<sup>31</sup>~2<sup>31</sup>-1|4 bytes|
|int64_t|64비트 크기의 부호있는 정수|-2<sup>63</sup>~2<sup>63</sup>-1|8 bytes|
|uint8_t|8비트 크기의 부호없는 정수|0~2<sup>8</sup>-1|1 byte|
|uint16_t|16비트 크기의 부호없는 정수|0~2<sup>16</sup>-1|2 bytes|
|uint32_t|32비트 크기의 부호없는 정수|0~2<sup>32</sup>-1|4 bytes|
|uint64_t|64비트 크기의 부호없는 정수|0~2<sup>64</sup>-1|8 bytes|

C는 `#include <stdint.h>`, C++은 `#include <cstdint>`를 통해 사용할 수 있다. Java의 경우는 JVM이 존재하고, 그 위에서는 항상 크기가 일정하기 때문에 크기가 변하는 것에 대해 걱정할 필요는 없을 것 같다. ~~Python은 이런거 신경 안쓴다~~

### 결과값이 이상해요: 실수

사칙연산에 정수가 아닌 실수를 넣고 해보면 값이 이상하게 나올 때가 있다. [기본적인 입출력]({{ site.baseurl}}/note/basic-io)에서 나오는 포맷 문자열과 함께 사용하면 조금 이상한 값을 얻을 수 있다.

```c
#include <stdio.h>

int main() {
    printf("%.17f", 0.1 + 0.2);
}
```

이렇게 하면 출력값이 `0.30000000000000004`가 나온다. `0.1 + 0.2`의 값이 정확히 `0.3`은 아니라는 것이다.[^3] 이는 마찬가지로 실수의 표현 방식에 대해 알면 이해할 수 있다.

#### 실수형의 범위와 특수값

C/C++ 기준으로 실수형은 `float`와 `double`이 있다. 실수 또한 Python은 미친듯이 넓은 범위를 자랑한다. C/C++은 아래와 같다.

|타입|범위|크기|
|float|±3.4028235×10<sup>38</sup> / ±(2-2<sup>-23</sup>)×2<sup>127</sup>|4 bytes|
|double|±1.7976931×10<sup>308</sup> / ±(2-2<sup>-51</sup>)×2<sup>1023</sup>|8 bytes|
|long double|±11897314×10<sup>4932</sup> / ±(2-2<sup>-63</sup>)×2<sup>16383</sup>|80 bits[^4]|

실수형 변수는 부호, 지수부, 가수부로 나뉜다. 부호 비트를 m, 지수부를 {e<sub>i</sub>}(n개 비트), 가수부를 {s<sub>i</sub>}(k개 비트)라고 하면 실수형 변수가 나타내는 값은 아래와 같다.

|경우|값|
|:-:|:-:|
|normalized value(지수부가 0 초과 2<sup>n</sup>-1 미만)|$(-1)^{m}\times 2^{e-2^{n-1}+1}\times (1.s_{k-1}s_{k-2}...s_{0})$|
|denormalized value(지수부가 0)|$(-1)^{m}\times 2^{2-2^{n-1}}\times (0.s_{k-1}s_{k-2}...s_{0})$|
|지수부가 2<sup>n</sup>-1이고 가수부가 0|부호 비트가 0일 경우 +∞, 1일 경우 -∞|
|지수부가 2<sup>n</sup>-1이고 가수부가 0이 아님|NaN|

일반적인 경우는 normalized value와 같이 값을 인식한다. 하지만 특수한 경우가 있는데, denormalized, infinity, 그리고 NaN이다. denormalized value는 지수부가 0인 경우인데, 계산법이 약간 다르다. 이는 normalized value의 최소값(`float`의 경우 $2^{2-2^{n-1}}$)과 0 사이의 간격을 일정하게 메꾸기 위해 사용하는 범위이다. Infinity는 말 그대로 무한대를 의미하며, 실제로는 이 타입이 표시할 수 있는 최대의 실수값을 넘어갔다는 의미로 쓰인다. NaN은 연산의 결과가 정의되지 않는다는 의미로 주로 쓰인다. $\sqrt{-1}$이나 $\frac{0}{0}$같은 경우 그 결과가 `NaN`으로 나온다.

#### 실수형 변수의 정확성

정수형 변수와는 다르게 실수형 변수는 나타낼 수 있는 값을 순서대로 나열했을 때 그 거리가 일정하지 않다. 가장 거리가 짧은 부분은 denormalized에서의 $2^{2-2^{n-1}}\times 2^{-k}$이고, 가장 거리가 긴 부분은 지수부가 특수값이 아닌 최대값(2<sup>n</sup>-2)일 때 $2^{2^{n-1}-2}\times 2^{-k}$이다. 값이 커질수록 그 간격도 커지는 경향성을 가진다. 이를 수직선에 나타낸 그림은 아래와 같다.

<img src="{{ site.baseurl }}/images/arithmetic_0.png" />
<small align=right>By Joeleoj123 - Own work, CC BY-SA 4.0, <a href="https://commons.wikimedia.org/w/index.php?curid=95784506">Link</a></small>

실수형 연산은 정수형 연산과는 다르게 숨겨진 비트 2개를 사용하는데, 연산의 결과값에 가장 가까운 나타낼 수 있는 실수값을 찾는 데에 사용된다. 이 과정에서 값의 정확성이 떨어지고, 그 결과 `0.30000000000000004`와 같은 경우가 발생하는 것이다.

정확성 때문에 발생하는 이슈가 하나 더 있다. 바로 연산의 순서에 따라 결과값이 달라진다는 것이다. 아래의 예시를 보면 알 수 있다.

```c
#include <stdio.h>

int main() {
    printf("%.15lf\n", 20000000000+0.000001+0.000001);
    printf("%.15lf\n", 20000000000+(0.000001+0.000001));
}
```

이것을 실행시키면 값이 각각 `20000000000.000000000000000`, `20000000000.000003814697266`이 나온다. 첫 번째 것은 더했는데도 심지어 값이 그대로다! 일반적인 수학이라면 덧셈의 순서가 어떻든 값이 같아야하지만(결합법칙) 여기서는 성립하지 않을 수가 있다.

### 정리

- 사칙연산
  - 연산자
    - `+`: 덧셈
    - `-`: 뺄셈
    - `*`: 곱셈
    - `/`: 정수의 경우 몫, 실수의 경우 나눗셈
    - `%`: 나머지
  - 연산 시 발생할 수 있는 오류
    - 오버플로우
    - 정확도
- 수를 저장하는 타입
  - 정수
    - `char`(1), `short`(2), `int`(4), `long`(4 or 8), `long long`(8), ...
  - 실수
    - `float`(4), `double`(8), `long double`(10), ...
  - 경우에 따라 적절한 타입을 선택해야 함

### 적당한 문제

- 사칙연산
  - [1000 - A+B](noj.am/1000)
  - [1001 - A-B](noj.am/1001)
  - [10998 - A×B](noj.am/10998)
  - [10869 - 사칙연산](noj.am/10869)
  - [10430 - 나머지](noj.am/10430)
  - [2588 - 곱셈](noj.am/2588)
- 수를 저장하는 타입 / [포맷 문자열]({{ site.baseurl }}/note/basic-io/#c)
  - [1008 - A/B](noj.am/1008)

<hr/>

[^1]: 환경에 따라 다르다.
[^2]: 편의상 가장 왼쪽이라고 했지만 big-endian, little-endian, middle-endian이냐에 따라 그 위치가 다르다.
[^3]: 특히 이 케이스의 경우 [여기](https://0.30000000000000004.com/)에서 다양한 언어에 대해 다루고 있다.
[^4]: `long double`이 80비트를 할당받아야 한다는 것은 강제사항은 아니다. 언어나 환경에 따라 변수의 크기가 다를 수도 있다. 경우에 따라 8바이트, 80비트, 16바이트 등을 사용한다.