---
title: "기초: 조건문 / 불 대수"
order: 20
category: 노트
layout: note

diff: 29

written: "2021-01-19 22:46"
edited: "2021-02-06 23:20"
---

※ 기초 태그가 붙어있는 포스트는 까먹을 만한/더 알면 좋은 것만 정리합니다

### C에서의 불 대수(`true` / `false`)

C에는 불 대수를 나타내는 타입이 존재하지 않는다. 대신 `int`를 이용하여 참/거짓을 저장한다. 하지만 `int`의 범위는 -2147483648~2147483647로 어느 값을 참으로, 어느 값은 거짓으로 인식해야 하는지가 궁금해진다. C는 보통 0을 거짓, 1을 참이라고 놓는다. 위의 논리 연산들이 C++, Java, Python에서는 `true`, `false`로 반환할 동안 C는 `1`과 `0`으로 반환한다. 즉, `3 < 5`의 반환값은 1인 것이다. 그러면 나머지 값은? C는 논리 연산의 반환값이 0과 1밖에 없지만 이외의 값에 대해서는 참과 거짓을 `x != 0`으로 판별한다. 즉, `int`의 값이 0만 아니면 이 변수를 참으로 인식, 0이면 거짓으로 인식한다. ~~이를 이용하면 숏코딩에 상당히 도움이 된다.~~ 따라서 아래와 같은 조건문을 사용할 수 있다.

```cpp
if (x) { } // if (x != 0) 과 같음
if (x - 7) { } // if (x != 7) 과 같음
```

### 논리 연산자와 비트 연산자

논리 연산은 하나의 비트를 가지고 진행하는 것인데, 이를 확장시켜 n바이트 단위의 정수형에도 적용한 연산자들이 있다. 이 연산자는 PS에 있어서 빠질 수 없는 연산자이며, 그 용도 또한 다양하다.

|종류|논리 연산|비트 연산|
|:-:|:-:|:-:|
|`AND`|`&&`|`&`|
|`OR`|`||`|`|`|
|`NOT`|`!`|`~`|
|`XOR`|`!=`|`^`|

여기에 bit-shift라는 비트 연산자도 있다. bit-shift는 비트의 위치를 특정 방향으로 일정 거리만큼 옮겨버린다.

|연산|의미|
|:-:|:-:|
|`x << n`|x의 모든 비트를 왼쪽으로 n만큼 이동|
|`x >> n`|x의 모든 비트를 오른쪽으로 n만큼 이동|

C/C++에서 비트를 옮길 때, 범위를 넘어가는 값은 모두 버리고, 빈 칸은 0으로 채운다. Java의 경우는 조금 다른데, 오른쪽으로 bit-shift를 진행할 경우, 빈 칸을 bit-shift하기 이전의 부호 비트값으로 채운다. 원래의 값이 음수였으면 1로, 양수였으면 0으로 채우는 셈이다. 대신 Java에서는 C/C++의 오른쪽 bit-shift 또한 사용할 수 있는데, 그 때에는 `>>>` 연산자를 사용한다. 이 연산자는 빈 칸을 모두 0으로 채운다.

`x << n`은 $x\times 2^n \mod 2^{32}$의 값을, `x >> n`은 $\left\lfloor{\frac{x}{2^n}}\right\rfloor$의 값을 가진다. 단, 음수의 unsigned right bit-shift(C/C++의 `>>`, Java의 `>>>`)는 부호가 바뀌므로 성립하지 않을 것이다.

비트 연산자는 PS에 자주 사용되는 <a href="" class="invalid">비트마스킹</a>에 주로 사용된다.

### ?:문

`if-else`문을 줄여서 아래와 같은 방식으로 쓸 수 있다. 작동 방식은 약간 다르겠지만 결과값은 똑같다.

- C/C++/Java

```cpp
n = n > 0 ? n : -n;
```

- Python

```python
n = n if n > 0 else -n
```

### 정리

- C에서의 불 대수
  - `int`형 변수 `x`에 대해 `x != 0`이면 `true`, 아니면 `false`
- 비트 연산자
  - 논리 연산을 각 비트마다 적용
  - `&`, `|`, `~`, `^`, `<<`, `>>`
- ?:문
  - `if-else` 구문이랑 결과가 같음
  - `(조건)?(참일 때):(거짓일 때)` (C/C++/Java)
  - `(참일 때) if (조건) else (거짓일 때)` (Python)