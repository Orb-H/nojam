---
title: "기초: 조건문 / 불 대수"
order: 20
category: 노트
layout: note

diff: 29

written: "2021-01-19 22:46"
edited: "2021-01-24 22:06"
---

조건문은 프로그램의 흐름에 분기를 주어 경우에 따라 다른 연산을 실행할 수 있도록 하는 문법이다. 일반적으로 사용하는 언어(C/C++/Java)는 `if`와 `switch`를 사용하며, Python은 `if`만 있고 `switch`는 없다. `if`문의 소괄호 안에 들어가는 값은 `boolean` 값으로 불 대수를 표현하는 타입이다. 일반적으로 관계 연산자가 포함된 식이 소괄호 안에 들어가며, 논리 연산자를 이용하여 더 복잡한 조건식을 만들기도 한다.

### 관계 연산자

관계 연산자는 이항 연산자[^2]로, 양쪽 두 값을 비교하여 그 대소 또는 동일 여부가 연산자가 나타내는 바와 같을 경우 `참`을 반환하는 연산자이다. 그 종류는 6가지가 있으며 아래와 같다.

|연산자|의미|
|:-:|:-:|
|`==`|양쪽의 값이 같을 때 참을 반환|
|`!=`|양쪽의 값이 다를 때 참을 반환|
|`>`|왼쪽 값이 오른쪽 값보다 클 때 참을 반환|
|`<`|오른쪽 값이 왼쪽 값보다 클 때 참을 반환|
|`>=`|왼쪽 값이 오른쪽 값보다 크거나 같을 때 참을 반환|
|`<=`|오른쪽 값이 왼쪽 값보다 크거나 같을 때 참을 반환|

예를 들자면 아래와 같다.

```cpp
2 == 3 // 거짓
2 != 3 // 참
4 == 4 // 참
4 != 4 // 거짓

6 > 3 // 참
6 < 3 // 거짓
6 >= 3 // 참
6 <= 3 // 거짓

4 > 4 // 거짓
4 < 4 // 거짓
4 >= 4 // 참
4 <= 4 // 참

2 > 7 // 거짓
2 < 7 // 참
2 >= 7 // 거짓
2 <= 7 // 참
```

### 불 대수

불 대수(`boolean`)는 값이 `true`(참)와 `false`(거짓)만 존재하는 하나의 대수이다. 불 대수에도 연산이 몇 가지 정의되어있다. 종류는 아래와 같다.

- NOT
- AND
- OR
- XOR
- NAND(NOT+AND)
- NOR(NOT+OR)
- XNOR(NOT+XOR)

#### NOT 연산

NOT 연산은 `!` 또는 `not`[^3]을 사용하며 단항 연산자[^1]이다. 주어진 값의 반대되는 값을 반환한다. 입력값에 따른 출력값은 아래와 같다.

|입력|출력|
|:-:|:-:|
|`true`|`false`|
|`false`|`true`|

#### AND 연산

AND 연산은 `&&` 또는 `and`[^3]를 사용하며 이항 연산자[^2]이다. 결과값은 이름에 걸맞게 둘 다 `true`일 때만 `true`를 반환한다. 모든 경우의 입력값에 따른 출력값은 아래와 같다.

|입력 1|입력 2|출력|
|:-:|:-:|:-:|
|`false`|`false`|`false`|
|`false`|`true`|`false`|
|`true`|`false`|`false`|
|`true`|`true`|`true`|

#### OR 연산

OR 연산은 `||` 또는 `or`[^3]를 사용하며 이항 연산자[^2]이다. 결과값은 둘 중 하나라도 `true`일 때 `true`를 반환한다. 모든 경우의 입력에 따른 출력값은 아래와 같다.

|입력 1|입력 2|출력|
|:-:|:-:|:-:|
|`false`|`false`|`false`|
|`false`|`true`|`true`|
|`true`|`false`|`true`|
|`true`|`true`|`true`|

#### XOR 연산

XOR 연산은 `!=`를 사용하며 이항 연산자[^2]이다. 결과값은 입력 둘 중 하나만 `true`일 때 `true`를 반환한다. 모든 경우의 입력에 따른 출력값은 아래와 같다.

|입력 1|입력 2|출력|
|:-:|:-:|:-:|
|`false`|`false`|`false`|
|`false`|`true`|`true`|
|`true`|`false`|`true`|
|`true`|`true`|`false`|

XOR은 논리회로 수업을 들었다면 ⊕로 알고있을텐데, XOR 연산은 사실상 두 논리값이 다를 때 `true`를 반환하는 연산으로도 볼 수 있다. 그래서 관계 연산자 중 `!=`를 사용하여 나타낼 수 있다. 이를 이용하면 XNOR 연산은 관계 연산자 중 `==`를 사용하여 표현할 수 있음을 알 수 있다.

#### 나머지(NAND, NOR, XNOR)

나머지 3개의 연산 모두 이항 연산자[^2]이다. 이 연산들은 위에 나온 연산자의 출력값에 NOT 연산을 취하여 값을 얻을 수 있다. NAND의 경우 AND의 출력값에 NOT 연산을 취하면 되고, 나머지도 마찬가지로 OR에 NOT, XOR에 NOT 연산을 적용한 값을 반환한다.

사실 NOT과 AND, NOT과 OR만으로 여기있는 모든 연산을 구현할 수 있으며, 동일 변수를 두 입력으로 집어넣을 수 있다고 가정했을 때에는 NAND 또는 NOR 연산 하나만 가지고 7가지 비트 연산을 모두 구현할 수 있다. 필요없는 내용이기는 하지만 신기해서 넣어봤다.

#### C에는 불 대수가 없다

C에는 불 대수를 나타내는 타입이 존재하지 않는다. 대신 `int`를 이용하여 참/거짓을 저장한다. 하지만 `int`의 범위는 -2147483648~2147483647로 어느 값을 참으로, 어느 값은 거짓으로 인식해야 하는지가 궁금해진다. C는 보통 0을 거짓, 1을 참이라고 놓는다. 위의 논리 연산들이 C++, Java, Python에서는 `true`, `false`로 반환할 동안 C는 `1`과 `0`으로 반환한다. 즉, `3 < 5`의 반환값은 1인 것이다. 그러면 나머지 값은? C는 논리 연산의 반환값이 0과 1밖에 없지만 이외의 값에 대해서는 참과 거짓을 `x != 0`으로 판별한다. 즉, `int`의 값이 0만 아니면 이 변수를 참으로 인식, 0이면 거짓으로 인식한다. ~~이를 이용하면 숏코딩에 상당히 도움이 된다.~~

#### 논리 연산자를 비트 연산자로 확장

논리 연산은 하나의 비트를 가지고 진행하는 것이었는데, 이를 확장시켜 n바이트 단위의 정수형에도 적용한 연산자들이 있다. 이 연산자는 PS에 있어서 빠질 수 없는 연산자이며, 그 용도 또한 다양하다. 논리 연산자와 대응되는 정수 연산자는 아래와 같다.

|종류|논리 연산|비트 연산|
|:-:|:-:|:-:|
|`AND`|`&&`|`&`|
|`OR`|`||`|`|`|
|`NOT`|`!`|`~`|
|`XOR`|`!=`|`^`|

작동 방식은 두 변수의 각 비트마다 모두 논리 연산을 적용한 값을 저장하는 것이다. 예를 들어 `int`에 대한 비트 AND 연산이면, 32개의 모든 비트에 대해 각각 논리 AND 연산을 진행한 값을 다시 `int`형으로 만든다. 다른 연산들도 마찬가지로 적용된다. 간단한 예시는 아래와 같다.

```cpp
9 & 12 == 8 // 1001 & 1100 = 1000
3 | 8 == 11 // 0011 | 1000 = 1011
6 ^ 10 == 12 // 0110 ^ 1010 = 1100
~3 = -4 // ~00000000 00000000 00000000 00000011 = 11111111 11111111 11111111 11111100
```

여기에 추가적으로 사용되는 비트 연산자들이 있다. 바로 bit-shift이다. bit-shift는 비트의 위치를 특정 방향으로 일정 거리만큼 옮겨버린다. 그 종류는 아래와 같다.

|연산|의미|
|:-:|:-:|
|`x << n`|x의 모든 비트를 왼쪽으로 n만큼 이동|
|`x >> n`|x의 모든 비트를 오른쪽으로 n만큼 이동|

C/C++에서 비트를 옮길 때, 범위를 넘어가는 값은 모두 버리고, 빈 칸은 0으로 채운다. Java의 경우는 조금 다른데, 오른쪽으로 bit-shift를 진행할 경우, 빈 칸을 bit-shift하기 이전의 부호 비트값으로 채운다. 원래의 값이 음수였으면 1로, 양수였으면 0으로 채우는 셈이다. 대신 Java에서는 C/C++의 오른쪽 bit-shift 또한 사용할 수 있는데, 그 때에는 `>>>` 연산자를 사용한다. 이 연산자는 빈 칸을 모두 0으로 채운다.

```cpp
3 << 2; // 12
14 >> 2; // 3
-1 >> 31; // 1(C/C++), -1(Java)
-4 >>> 27; // 3, Java만 가능
```

값을 바꿔가면서 테스트를 해보면 특이한 점을 알 수 있는데, 왼쪽 방향의 bit-shift는 2의 제곱수를 곱하는 것과 비슷한 것을 알 수 있다. 즉, `x << n`이라고 쓰면 $x\times 2^n$의 값을 가진다고 유추해볼 수 있다.[^4] 반대로 오른쪽 방향의 bit-shift는 2의 제곱수로 나눈 것에 floor 연산을 취한 것이라고 생각할 수 있다. `x >> n`이면 $\left\lfloor{\frac{x}{2^n}}\right\rfloor$의 값을 가진다. 단, 음수의 unsigned right bit-shift(C/C++의 `>>`, Java의 `>>>`)는 부호가 바뀌므로 성립하지 않을 것이다.

비트 연산자는 PS에 자주 사용되는 **비트마스킹**에 주로 사용된다.

### if문

가장 일반적으로 쓰이는 조건문이다. 형태는 언어별로 아래와 같다.

- C/C++/Java

```cpp
if (조건식1) {
    ...
} else if (조건식2) {
    ...
} else {
    ...
}
```

- Python

```python
if 조건식1:
    ...
elif 조건식2:
    ...
else:
    ...
```

`if`문의 소괄호 안에 들어가는 조건식은 C를 제외한 경우는 `boolean` / `bool` 타입으로 한정되고, C는 `int` 타입이어야 한다. C는 조건문의 참/거짓을 위에서 설명한 것과 같이 `x != 0`으로 판별한다.

첫 번째 조건(조건식1)에 해당되지 않는 경우에만 코드를 실행시키고 싶을 때에는 `else`를 사용한다. 이렇게 하면 조건식1을 만족하는 경우는 `if`문 안의 코드를, 아닌 경우는 `else`문 안의 코드를 실행하게 된다. 추가적으로 위의 경우와 같이 첫 번째 조건이 아닌 경우 중 두 번째 조건을 만족하는 경우를 찾고 싶을 때에는 C/C++/Java는 `else if`, Python은 `elif`를 사용하여 찾을 수 있다. 마찬가지로 해당되는 구문의 코드만 실행된다.

### ?:문

신기하게도 `if(조건) 코드 else 코드`를 줄여서 쓸 수 있는 구문이 있는데, 바로 `?:`문이다. `(조건)?(참일 때 값/코드):(거짓일 때 값/코드)` 형태로 사용된다. 예시는 아래와 같다.

- C/C++/Java

```cpp
n = n > 0 ? n : -n;
```

- Python

```python
n = n if n > 0 else -n
```

Python은 다른 언어와 달리 `(참일 때 값/코드) if (조건문) else (거짓일 때 값/코드)` 형태를 가지지만 개념은 같다. 위의 코드 둘 다 변수 n에 n의 절댓값을 저장하는 코드이다.

### switch문

`switch`는 `if`와 다르게 불 대수를 필요로 하지 않는 조건 구문이다. 형태는 C/C++/Java 공통으로 아래와 같다. Python은 아쉽게도 `switch` 구문이 존재하지 않는다.

```cpp
int n;
...
switch(n) {
    case 0:
        printf("즐겁다!");
        break;
    case 1:
        printf("샌즈! ");
    case 2:
        printf("아시는구나!");
        break;
    default:
        printf("마참내!");
        break;
}
```

`n`의 값에 따른 출력값은 아래와 같다.

|n의 값|출력|
|:-:|:-:|
|`0`|`즐겁다!`|
|`1`|`샌즈! 아시는구나!`|
|`2`|`아시는구나!`|
|이외의 값|`마참내!`|

`break`는 각 case별 코드를 실행 후 `switch`문을 빠져나가라는 의미로 사용되는데, `break`를 사용하지 않으면 다음 case의 코드도 이어서 실행하게 된다. 위의 코드에서 case 1에는 `break`가 없으므로 `n == 1`일 때 `n == 2`의 코드도 같이 실행된다. `default`는 명시된 case를 제외한 경우에 대한 코드를 작성하겠다는 의미로 사용된다.

### 정리

- 관계 연산자
  - `==`, `!=`, `>`, `<`, `>=`, `<=`
- 불 대수
  - `참`과 `거짓`의 값만 가지는 타입
  - 논리 연산(NOT, AND, OR, XOR, NAND, NOR, XNOR)
- 비트 연산자
  - 논리 연산을 각 비트마다 적용
  - `&`, `|`, `~`, `^`, `<<`, `>>`
- if문
  - 프로그램을 분기
  - 조건에는 `boolean` 값(C 제외)
  - if-else, if-else if(elif)-else 구문
- switch문
  - 값(정수)에 따라 다른 코드 실행
  - case 키워드로 특정 값일 때의 코드 작성

<hr/>

[^1]: 연산자가 적용되는 피연산자가 하나인 연산이다. 보통 `!A`와 같이 표기한다.
[^2]: 피연산자가 두 개인 연산이다. 일반적으로 중위 표기법을 이용하여 `A && B`와 같은 꼴로 표현한다.
[^3]: Python 한정
[^4]: 정확히는 정수형의 범위에 한정되어 truncated된 값이다. [정수형의 범위와 오버플로우]({{ site.baseurl }}/note/arithmetic/#정수형의-범위와-오버플로우) 참조